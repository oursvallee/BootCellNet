# MDS/FVS algorithms
# 9/12/2023
#
# summary of the below two
# C:/work/20230212_cellstrap/20230710_scrna_test_6/20230724_1_test.R
# C:/work/20230212_cellstrap/20230908_scrna_test_7/20230908_1_test.R
#
# for usage, see C:/work/20230212_cellstrap/20230908_scrna_test_7/20230911_summary_algorithms.R
#
# 11/16/2023: ver 2, storing parameters into list; clean up obsolete codes
########################################################

#=======================================================
# calculate MDS and store the data
# ar.graph: list of graph parameters generated by cleanGRN in BCN
# dealing with only "clean" graph
MDSGRN <- function(ar.graph){
  
  a <- ar.graph$graph.clean$graph
  
  mds <- mds.ip(a, genes=TRUE)
  
  node.shape <- rep("circle", vcount(a))
  node.shape[names(V(a)) %in% mds] <- "square"
  
  ar.graph$graph.clean[["MDS"]] <- mds
  ar.graph$graph.clean[["node_shape_MDS"]] <- node.shape
  
  return(ar.graph)
  
}

#=======================================================
# calculate FVS w/ cavity method and store the data
# ar.graph: list of graph parameters generated by cleanGRN in BCN
# dealing with only "clean" graph
# other arguments are used by the fvs.cav function
# x is used to avoid loss of digits
# probs are multiplied #(degree of node) times, 
# thus x should be large enough so that x/#(degree) is enough large (maybe...)

FVSGRN <- function(ar.graph, x=100, tmax=1e2, f=0){
  
  a <- ar.graph$graph.clean$graph
  
  fvs <- fvs.cav(a, x=x, tmax=tmax, f=f)
  fvs <- sort(fvs)
  
  node.shape <- rep("circle", vcount(a))
  node.shape[names(V(a)) %in% fvs] <- "square"
  
  ar.graph$graph.clean[["FVS"]] <- fvs
  ar.graph$graph.clean[["node_shape_FVS"]] <- node.shape
  
  return(ar.graph)
  
}

# usage
# ar.graph <- MDSGRN(ar.graph)
# ar.graph <- FVSGRN(ar.graph)
# pdf("20231115_pbmc-GRNs_MDS-FVS.pdf")
# plot(ar.graph$graph.clean$graph, layout=ar.graph$graph.clean$layout,
#      vertex.color="white", vertex.cex=0.5, vertex.size=10, vertex.label.cex=0.5,
#      edge.width=ar.graph$graph.clean$weight, vertex.shape=ar.graph$graph.clean$node_shape_MDS)
# 
# plot(ar.graph$graph.clean$graph, layout=ar.graph$graph.clean$layout,
#      vertex.color="white", vertex.cex=0.5, vertex.size=10, vertex.label.cex=0.5,
#      edge.width=ar.graph$graph.clean$weight, vertex.shape=ar.graph$graph.clean$node_shape_FVS)
# dev.off()


#=======================================================
# check FVS consistency, and clean up
# remove one-by-one
# argument is the output of FVSGRN
checkFVS <- function(ar.graph, x=100, tmax=1e2, f=.01){
  
  a.clean <- ar.graph$graph.clean
  fvs <- ar.graph$graph.clean$FVS
  
  n <- vector(length=length(fvs))
  names(n) <- fvs
  
  for(i in 1:length(fvs)){
    n[i] <- length(clean_graph(delete.vertices(a.clean$graph, a.clean$FVS[-i]))) 
  }
  
  return(n)
  
}


#=======================================================
# MDS as an integer programming problem

#--------------------------------------
# translate to an integer programming
# input a graph of igraph format, and return a list of genes (or a lpsolve object)

# cf a1 and a2 are identical
# a1 <- as_adjacency_matrix(ar.graph)
# a2 <- matrix(rep(0,129*129),nrow=129,ncol=129)
# a2[aracne.mtx>0]<-1
# max(a1-a2)

mds.ip <- function(graph, genes=T){
  require(lpSolve)
  require(igraph)
  
  a <- as_adjacency_matrix(graph)
  
  n <- dim(a)[1]
  
  f.obj <- rep(1,n)
  f.con <- as.matrix(a)
  f.con <- f.con+diag(rep(1,n))
  f.dir <- rep(">=",n)
  f.rhs <- rep(1,n)
  
  lpsol <- lp("min", f.obj, f.con, f.dir, f.rhs, int.vec=1:n, all.bin=T)
  
  if(genes){
    return(colnames(lpsol$constraints)[lpsol$solution==1])
  }
  else{
    return(lpsol)
  }  
}
# MDS as an integer programming problem end
#=======================================================


#=======================================================
# FVS as a spin glass problem
# use Cavity method
# input a graph, return a set of genes

#--------------------------------------
# first, bp loop
# take a graph, return a vector of the empty probabilities, q^0_i

fvs.bp <- function(graph, x=10, tmax=1e2){
  require(igraph)
  
  a <- as_adjacency_matrix(graph)
  n <- dim(a)[1]
  
  a1 <- as.numeric(a + diag(1,n))
  a.nz <- sum(a1>0)
  
  # initialization
  # q0[i,j] = q^0_{i\to j}
  # qi[i,j] = q^i_{i\to j}
  # z1[i,j] = z_{i\to j}
  q0 <- matrix(rep(0,n*n), nrow=n, ncol=n)
  q0[a1>0] <- runif(a.nz, 0, 1)
  
  qi <- matrix(rep(0,n*n), nrow=n, ncol=n)
  qi[a1>0] <- runif(a.nz, 0, 1)
  
  z1 <- matrix(rep(0,n*n), nrow=n, ncol=n)
  
  # q[i] = q^0_i
  # z[i] = z_i 
  q <- rep(0,n)
  z <- rep(0,n)
  
  ex <- exp(x)
  
  # BP iteration
  for(t in 1:tmax){
    node.ord <- sample(1:n, n)
    
    for(i in node.ord){
      Di <- (1:n)[a[i,]>0] # adjacent nodes of i
      
      for(jinx in 1:length(Di)){
        j <- Di[jinx]
        z1st <- 1
        z2nd <- rep(0,length(Di[-jinx]))
        
        if(length(Di)>2){
          for(kinx in 1:length(Di[-jinx])){
            k <- (Di[-jinx])[kinx]
            z1st <- z1st*(q0[k,i]+qi[k,i])
            z2nd[kinx] <- (1-q0[k,i])*exp(sum(log(q0[Di[-c(jinx,kinx)],i]+qi[Di[-c(jinx,kinx)],i])))
          }
        }
        
        z1[i,j] <- 1+ex*(z1st+sum(z2nd))
        
        q0[i,j] <- 1/z1[i,j]
        qi[i,j] <- ex*z1st*q0[i,j]
        
        
      } # j in Di loop
      
    } # i loop
    
  } # t loop
  
  
  # calculate z and q
  for(i in 1:n){
    Di <- (1:n)[a[i,]>0] # adjacent nodes of i
    
    z1st <- exp(sum(log(q0[Di,i]+qi[Di,i])))
    z2nd <- 0
    for(jinx in 1:length(Di)){
      j <- Di[jinx]
      z2nd <- z2nd + (1-q0[j,i])*exp(sum(log(q0[Di[-jinx],i]+qi[Di[-jinx],i])))
    }
    
    z[i] <- 1+ex*(z1st+z2nd)
    q[i] <- 1/z[i]
    
  }
  
  return(q)
  
}

#--------------------------------------
# wrapper
fvs.cav <- function(graph, x=10, tmax=1e2, f=0.05){
  require(igraph)
  
  Gamma <- NULL
  
  graph <- clean_graph(graph)
  V <- V(graph)
  
  while(length(V)>0){
    nv <- floor(length(V)*f)+1
    q <- fvs.bp(graph, x=x, tmax=tmax)
    
    # select vertexes with the nv-th highest q0 and add to FVS
    fv.inx <- rev(order(q))[1:nv]
    fv <- names(V)[fv.inx]
    Gamma <- c(Gamma, fv)
    
    # remove FV and edges
    graph <- delete.vertices(graph, fv)
    
    # clean graph
    graph <- clean_graph(graph)
    V <- V(graph)
  }
  
  return(Gamma)
  
}
# FVS as a spin glass problem end
#=======================================================



#=======================================================
# helper functions
#--------------------------------------
# clean graph
# give a graph, return a graph w/o vertexes of 0 or 1 degree
remove_low_degree <- function(graph) {
  require(igraph)
  V <- V(graph)
  to_remove <- V[degree(graph) <= 1]
  if(length(to_remove) > 0) {
    graph <- delete.vertices(graph, to_remove)
  }
  return(graph)
}

clean_graph <- function(graph){
  require(igraph)
  d <- degree(graph)
  n_to_remove <- sum(d<=1)
  while(n_to_remove>0){
    graph <- remove_low_degree(graph)
    d <- degree(graph)
    n_to_remove <- sum(d<=1)
  }
  return(graph)
}


